with text_io;                            use text_io;
with Communications_with_User;           use Communications_with_User;
with Standard_Floating_Numbers;          use Standard_Floating_Numbers;
with Standard_Floating_Numbers_io;       use Standard_Floating_Numbers_io;
with Standard_Random_Numbers;
with Double_Double_Basics;

procedure ts_pentadbl is

-- DESCRIPTION :
--   Test development procedure for penta double arithmetic,
--   extending the range of the quad double libary,
--   with code generated from the software CAMPARY.

-- DATA STRUCTURE :
--   Five doubles define a penta double number.
--   The parts of a penta double are stored as five doubles in a record.
--   The names of the parts are the names of the fingers,
--   starting with the thumb for the most significant part
--   and ending with pink for the least significant part.

  type penta_double is record
    thumb : double_float;  -- highest double, most significant part
    index : double_float;  -- second most significant double
    middle : double_float; -- middle double, third most significant part
    ring : double_float;   -- second least significant double
    pink : double_float;   -- lowest double, least significant part
  end record;

  function create ( x : double_float ) return penta_double is

  -- DESCRIPTION :
  --   The highest word in the penta double on return equals x.

    res : penta_double;

  begin
    res.thumb := x;
    res.index := 0.0;
    res.middle := 0.0;
    res.ring := 0.0;
    res.pink := 0.0;
    return res;
  end create;

  function thumb_part ( x : penta_double ) return double_float is
  begin
    return x.thumb;
  end thumb_part;

  function index_part ( x : penta_double ) return double_float is
  begin
    return x.index;
  end index_part;

  function middle_part ( x : penta_double ) return double_float is
  begin
    return x.middle;
  end middle_part;

  function ring_part ( x : penta_double ) return double_float is
  begin
    return x.ring;
  end ring_part;

  function pink_part ( x : penta_double ) return double_float is
  begin
    return x.pink;
  end pink_part;

  procedure write ( x : penta_double ) is

  -- DESCRIPTION :
  --   Writes all parts of x, one part per line.

  begin
    put("  thumb  : "); put(thumb_part(x),2,17,3); new_line;
    put("  index  : "); put(index_part(x),2,17,3); new_line;
    put("  middle : "); put(middle_part(x),2,17,3); new_line;
    put("  ring   : "); put(ring_part(x),2,17,3); new_line;
    put("  pink   : "); put(pink_part(x),2,17,3); new_line;
  end Write;

  procedure renorm5
              ( f0,f1,f2,f3,f4,f5 : in double_float;
                pr : in out double_float;
                r0,r1,r2,r3,r4 : out double_float ) is

  -- DESCRIPTION :
  --   Definitions common to fast_renorm2L<6,5> and renorm2L_4Add1<5,5>
  --   from code of the specRenorm.h, generated by the CAMPARY library,
  --   in an unrolled form (Valentina Popescu, Mioara Joldes), with
  --   double double basics of QD-2.3.9 (Y. Hida, X.S. Li, and D.H. Bialey).

  -- ON ENTRY :
  --   x0       most significant word;
  --   x1       second most significant word;
  --   x2       third most significant word;
  --   x3       fourth most significant word;
  --   x4       fifth most significant word;
  --   x5       sixth most significant word;
  --   pr       computed by the start of the renormalization.

  -- ON RETURN :
  --   pr       updated value by renormalization;
  --   r0       highest part of a penta double number;
  --   r1       second highest part of a penta double number;
  --   r2       middle part of a penta double number.
  --   r3       second lowest part of a penta double number;
  --   r4       lowest part of a penta double number.

    ptr : integer;

  begin
    if f1 = 0.0 then
      pr := f0;
      ptr := 0;
      Double_Double_Basics.quick_two_sum(pr,f2,r0,pr);
    else
      r0 := f0;
      pr := f1;
      ptr := 1;
      Double_Double_Basics.quick_two_sum(pr,f2,r1,pr);
    end if;
    if pr = 0.0 then
      if ptr = 0
       then pr := r0;
       else pr := r1;
      end if;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f3,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f3,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f3,r2,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f4,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f4,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f4,r2,pr);
      when 3 => Double_Double_Basics.quick_two_sum(pr,f4,r3,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when 3 => pr := r3;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f5,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f5,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f5,r2,pr);
      when 3 => Double_Double_Basics.quick_two_sum(pr,f5,r3,pr);
      when 4 => Double_Double_Basics.quick_two_sum(pr,f5,r4,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when 3 => pr := r3;
        when 4 => pr := r4;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    if ptr < 5 and pr /= 0.0 then
      case ptr is
        when 0 => r0 := pr;
        when 1 => r1 := pr;
        when 2 => r2 := pr;
        when 3 => r3 := pr;
        when 4 => r4 := pr;
        when others => null;
      end case;
      ptr := ptr + 1;
    end if;
    if ptr < 1 then
      r4 := 0.0; r3 := 0.0; r2 := 0.0; r1 := 0.0; r0 := 0.0;
    elsif ptr < 2 then
      r4 := 0.0; r3 := 0.0; r2 := 0.0; r1 := 0.0;
    elsif ptr < 3 then
      r4 := 0.0; r3 := 0.0; r2 := 0.0;
    elsif ptr < 4 then
      r4 := 0.0; r3 := 0.0;
    elsif ptr < 5 then
      r4 := 0.0;
    end if;
  end renorm5;

  procedure fast_renorm
              ( x0,x1,x2,x3,x4,x5 : in double_float;
                r0,r1,r2,r3,r4 : out double_float ) is

  -- DESCRIPTION :
  --   The definition is based on the fast_renorm2L<6,5>,
  --   from code of the specRenorm.h, generated by the CAMPARY library,
  --   in an unrolled form (Valentina Popescu, Mioara Joldes), with
  --   double double basics of QD-2.3.9 (Y. Hida, X.S. Li, and D.H. Bialey).

  -- ON ENTRY :
  --   x0       most significant word;
  --   x1       second most significant word;
  --   x2       third most significant word;
  --   x3       fourth most significant word;
  --   x4       fifth most significant word;
  --   x5       least significant word.

  -- ON RETURN :
  --   r0       highest part of a penta double number;
  --   r1       second highest part of a penta double number;
  --   r2       middle part of a penta double number.
  --   r3       second lowest part of a penta double number;
  --   r4       lowest part of a penta double number.

    f0,f1,f2,f3,f4,f5,pr : double_float;

  begin
    Double_Double_Basics.quick_two_sum(x4,x5,pr,f5);
    Double_Double_Basics.quick_two_sum(x3,pr,pr,f4);
    Double_Double_Basics.quick_two_sum(x2,pr,pr,f3);
    Double_Double_Basics.quick_two_sum(x1,pr,pr,f2);
    Double_Double_Basics.quick_two_sum(x0,pr,f0,f1);
    renorm5(f0,f1,f2,f3,f4,f5,pr,r0,r1,r2,r3,r4);
  end fast_renorm;

  procedure renorm_add1
              ( x0,x1,x2,x3,x4 : in double_float;
                y : in double_float;
                r0,r1,r2,r3,r4 : out double_float ) is

  -- DESCRIPTION :
  --   The definition is based on the renorm2L_4Add1<5,5>,
  --   from code of the specRenorm.h, generated by the CAMPARY library,
  --   in an unrolled form (Valentina Popescu, Mioara Joldes), with
  --   double double basics of QD-2.3.9 (Y. Hida, X.S. Li, and D.H. Bialey).

  -- ON ENTRY :
  --   x0       most significant word of a penta double x;
  --   x1       second most significant word of a penta double x;
  --   x2       third most significant word of a penta double x;
  --   x3       fourth most significant word of a penta double x;
  --   x4       least significant word of a penta double x;
  --   y        double to be added to x.

  -- ON RETURN :
  --   r0       highest part of x + y;
  --   r1       second highest part of x + y;
  --   r2       middle part of x + y;
  --   r3       second lowest part of x + y;
  --   r4       lowest part of x + y.

    f0,f1,f2,f3,f4,f5,pr : double_float;

  begin
    Double_Double_Basics.quick_two_sum(x4,y,pr,f5);
    Double_Double_Basics.quick_two_sum(x3,pr,pr,f4);
    Double_Double_Basics.quick_two_sum(x2,pr,pr,f3);
    Double_Double_Basics.quick_two_sum(x1,pr,pr,f2);
    Double_Double_Basics.quick_two_sum(x0,pr,f0,f1);
    renorm5(f0,f1,f2,f3,f4,f5,pr,r0,r1,r2,r3,r4);
  end renorm_add1;

  function "+" ( x,y : penta_double ) return penta_double is

  -- DESCRIPTION :
  --   Returns the sum x + y of two penta doubles x and y.

  -- ALGORITHM : baileyAdd_fast<5,5,5> generated by CAMPARY.

    res : penta_double;
    f0,f1,f2,f3,f4,f5,e : double_float;

  begin
    f5 := 0.0;
    Double_Double_Basics.two_sum(x.pink,y.pink,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(x.ring,y.ring,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(x.middle,y.middle,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(x.index,y.index,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(x.thumb,y.thumb,f0,e);
    Double_Double_Basics.two_sum(f1,e,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    fast_renorm(f0,f1,f2,f3,f4,f5,
                res.thumb,res.index,res.middle,res.ring,res.pink);
    return res;
  end "+";

  function "+" ( x : penta_double; y : double_float ) return penta_double is

  -- ALGORITHM : baileyAdd_fast<5,1,5> generated by CAMPARY.

    res : penta_double;

  begin
    renorm_add1(x.thumb,x.index,x.middle,x.ring,x.pink,y,
                res.thumb,res.index,res.middle,res.ring,res.pink);
    return res;
  end "+";

  function "-" ( x : penta_double ) return penta_double is

  -- DESCRIPTION :
  --   Returns -x, flipping the sign of all parts of x.

    res : penta_double;

  begin
    res.thumb := -x.thumb;
    res.index := -x.index;
    res.middle := -x.middle;
    res.ring := -x.ring;
    res.pink := -x.pink;
    return res;
  end "-";

  function "-" ( x,y : penta_double ) return penta_double is

  -- DESCRIPTION :
  --   Returns x - y, the difference between the penta doubles x and y.

    mny : constant penta_double := -y;
    res : constant penta_double := x + mny;

  begin
    return res;
  end "-";

  function "*" ( x,y : penta_double ) return penta_double is

  -- DESCRIPTION :
  --   Returns x*y, the product of two penta doubles x and y.

  -- ALGORITHM : baileyMul_fast<5,5,5> generated by CAMPARY.

    res : penta_double;
    f0,f1,f2,f3,f4,f5,p,e : double_float;

  begin
    f5 := x.index*y.pink;
    f5 := f5 + x.middle*y.ring;
    f5 := f5 + x.ring*y.middle;
    f5 := f5 + x.pink*y.index;
    Double_Double_Basics.two_prod(x.thumb,y.pink,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.index,y.ring,p,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f4,p,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.middle,y.middle,p,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f4,p,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.ring,y.index, p,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f4,p,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.pink,y.thumb,p,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f4,p,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.thumb,y.ring,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.index,y.middle,p,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f3,p,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.middle,y.index,p,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f3,p,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.ring,y.thumb,p,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f3,p,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.thumb,y.middle,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.index,y.index,p,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f2,p,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.middle,y.thumb,p,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f2,p,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.thumb,y.index,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.index,y.thumb,p,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_sum(f1,p,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.thumb,y.thumb,f0,e);
    Double_Double_Basics.two_sum(f1,e,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    fast_renorm(f0,f1,f2,f3,f4,f5,
                res.thumb,res.index,res.middle,res.ring,res.pink);
    return res;
  end "*";

  function "*" ( x : penta_double; y : double_float ) return penta_double is

  -- DESCRIPTION :
  --   Returns x*y, the product of the penta double x with the double y.

  -- ALGORITHM : baileyMul_fast<5,1,5>

    res : penta_double;
    f0,f1,f2,f3,f4,f5,e : double_float;

  begin
    f5 := 0.0;
    Double_Double_Basics.two_prod(x.pink,y,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.ring,y,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.middle,y,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.index,y,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    Double_Double_Basics.two_prod(x.thumb,y,f0,e);
    Double_Double_Basics.two_sum(f1,e,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    f5 := f5 + e;
    fast_renorm(f0,f1,f2,f3,f4,f5,
                res.thumb,res.index,res.middle,res.ring,res.pink);
    return res;
  end "*";

  function "*" ( x : double_float; y : penta_double ) return penta_double is

  -- DESCRIPTION :
  --   Returns x*y, the product of the double x with the penta double y.

    res : constant penta_double := y*x;

  begin
    return res;
  end "*";

  function "/" ( x,y : penta_double ) return penta_double is

    res,acc : penta_double;
    q0,q1,q2,q3,q4,q5 : double_float;

  begin
    q0 := x.thumb/y.thumb;   acc := q0*y; res := x - acc;
    q1 := res.thumb/y.thumb; acc := q1*y; res := res - acc;
    q2 := res.thumb/y.thumb; acc := q2*y; res := res - acc;
    q3 := res.thumb/y.thumb; acc := q3*y; res := res - acc;
    q4 := res.thumb/y.thumb; acc := q4*y; res := res - acc;
    q5 := res.thumb/y.thumb;
    fast_renorm(q0,q1,q2,q3,q4,q5,
                res.thumb,res.index,res.middle,res.ring,res.pink);
    return res;
  end "/";

  function "/" ( x : penta_double; y : double_float ) return penta_double is

    pdy : constant penta_double := create(y);
    res : constant penta_double := x/pdy;

  begin
    return res;
  end "/";

  function "/" ( x : double_float; y : penta_double ) return penta_double is

    pdx : constant penta_double := create(x);
    res : constant penta_double := pdx/y;

  begin
    return res;
  end "/";

  function random return penta_double is

  -- DESCRIPTION :
  --   Returns a random penta double number from adding
  --   random double numbers in [-1,+1].

    res : penta_double;
    first : constant double_float := Standard_Random_Numbers.Random; 
    second : double_float := Standard_Random_Numbers.Random; 
    eps : constant double_float := 2.0**(-52);
    multiplier : double_float := eps;

  begin
    res := create(first);
    res := res + eps*second;
    for k in 3..5 loop
      multiplier := eps*multiplier;
      second := Standard_Random_Numbers.Random;
      res := res + multiplier*second;
    end loop;
    return res;
  end random;

  procedure Test_Addition_and_Subtraction is

  -- DESCRIPTION :
  --   Generates two random numbers, adds and subtracts.

    x : constant penta_double := random;
    y : constant penta_double := random;
    z : constant penta_double := x + y;
    v : constant penta_double := z - y;

  begin
   put_line("All parts of a random octo double x :"); Write(x);
   put_line("All parts of a random octo double y :"); Write(y);
   put_line("All parts of x + y :"); Write(z);
   put_line("All parts of (x + y) - y :"); Write(v);
  end Test_Addition_and_Subtraction;

  procedure Test_Multiplication_and_Division is

  -- DESCRIPTION :
  --   Generates two random numbers, multiplies and divides.

    x : constant penta_double := random;
    y : constant penta_double := random;
    z : constant penta_double := x*y;
    v : constant penta_double := z/y;

  begin
   put_line("All parts of a random penta double x :"); Write(x);
   put_line("All parts of a random penaa double y :"); Write(y);
   put_line("All parts of x * y :"); Write(z);
   put_line("All parts of (x * y) / y :"); Write(v);
  end Test_Multiplication_and_Division;

  procedure Main is

  -- DESCRIPTION :
  --   Prompts for a test.

    ans : character;

  begin
    new_line;
    put_line("Testing penta double arithmetic ...");
    put_line("  1. test addition and subtraction");
    put_line("  2. test multiplication and division");
    put("Type 1 or 2 to select a test : "); Ask_Alternative(ans,"12");
    case ans is
      when '1' => Test_Addition_and_Subtraction;
      when '2' => Test_Multiplication_and_Division;
      when others => null;
    end case;
  end Main;

begin
  Main;
end ts_pentadbl;

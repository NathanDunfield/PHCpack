with text_io;                            use text_io;
with Standard_Integer_Numbers;           use Standard_Integer_Numbers;
with Standard_Floating_Numbers;          use Standard_Floating_Numbers;
with Double_Double_Basics;
with Quad_Double_Numbers;                use Quad_Double_Numbers;
with Quad_Double_Numbers_io;             use Quad_Double_Numbers_io;
with QuadDobl_Random_Numbers;            use QuadDobl_Random_Numbers;
with QuadDobl_Mathematical_Functions;

procedure ts_tridbl is

-- DESCRIPTION :
--   This procedure develops triple double arithmetic,
--   interpolating between double double and quad double arithmetic,
--   with generated code from the CAMPARY library.

  type triple_double is record
    hi : double_float; -- highest word, most significant part
    mi : double_float; -- middle word, second most significant part
    lo : double_float; -- lowest word, least significant part
  end record;

  function to_triple_double ( x : quad_double ) return triple_double is

  -- DESCRIPTION :
  --   Copies the first three words of x into the result.

    res : triple_double;

  begin
    res.hi := hihi_part(x);
    res.mi := lohi_part(x);
    res.lo := hilo_part(x);
    return res;
  end to_triple_double;

  function create ( x : triple_double ) return quad_double is

  -- DESCRIPTION :
  --   Copies the words of x into the first three words of the result.

    res : constant quad_double := create(x.hi,x.mi,x.lo,0.0);

  begin
    return res;
  end create;

  procedure fast_renorm
              ( x0,x1,x2,x3 : in double_float;
                r0,r1,r2 : out double_float ) is

  -- DESCRIPTION :
  --   This is based on the fast_renorm2L<4,3>,
  --   from code of the specRenorm.h, generated by CAMPARY.

    f0,f1,f2,f3,pr : double_float;
    ptr : integer32;

  begin
    Double_Double_Basics.quick_two_sum(x2,x3,pr,f3);  
    Double_Double_Basics.quick_two_sum(x1,pr,pr,f2);  
    Double_Double_Basics.quick_two_sum(x0,pr,f0,f1);  
    if f1 = 0.0 then
      pr := f0;
      ptr := 0;
      Double_Double_Basics.quick_two_sum(pr,f2,r0,pr);
    else
      r0 := f0;
      pr := f1;
      ptr := 1;
      Double_Double_Basics.quick_two_sum(pr,f2,r1,pr);
    end if;
    if pr = 0.0 then
      if ptr = 0
       then pr := r0;
       else pr := r1;
      end if;
    else
      ptr := ptr + 1;
    end if;
    if ptr = 0 then
      Double_Double_Basics.quick_two_sum(pr,f3,r0,pr);
    elsif ptr = 1 then
      Double_Double_Basics.quick_two_sum(pr,f3,r1,pr);
    else
      Double_Double_Basics.quick_two_sum(pr,f3,r2,pr);
    end if;
    if pr = 0.0 then
      if ptr = 0 then
        pr := r0;
      elsif ptr = 1 then
        pr := r1;
      else
        pr := r2;
      end if;
    else
      ptr := ptr + 1;
    end if;
    if ptr < 3 and pr /= 0.0 then
      if ptr = 0 then
        r0 := pr;
      elsif ptr = 1 then
        r1 := pr;
      else
        r2 := pr;
      end if;
      ptr := ptr + 1;
    end if;
    if ptr < 1 then
      r0 := 0.0; r1 := 0.0; r2 := 0.0;
    elsif ptr < 2 then
      r1 := 0.0; r2 := 0.0;
    elsif ptr < 3 then
      r2 := 0.0;
    end if;
  end fast_renorm;

  function "+" ( x,y : triple_double ) return triple_double is

  -- DESCRIPTION :
  --   Returns the sum x + y of the triple doubles x and y.

    res : triple_double;
    f0,f1,f2,f3,e : double_float;

  begin
    f3 := 0.0;
    Double_Double_Basics.two_sum(x.lo,y.lo,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_sum(x.mi,y.mi,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_sum(x.hi,y.hi,f0,e);
    Double_Double_Basics.two_sum(f1,e,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    fast_renorm(f0,f1,f2,f3,res.hi,res.mi,res.lo);
    return res;
  end "+";

  function "-" ( x : triple_double ) return triple_double is

  -- DESCRIPTION :
  --   Returns -x.

    res : triple_double;

  begin
    res.hi := -x.hi;
    res.mi := -x.mi;
    res.lo := -x.lo;
    return res;
  end "-";

  function "-" ( x,y : triple_double ) return triple_double is

  -- DESCRIPTION :
  --   Returns x - y, for two triple doubles x and y.

    mny : constant triple_double := -y;
    res : constant triple_double := x + mny;

  begin
    return res;
  end "-";

  function "*" ( x,y : triple_double ) return triple_double is

  -- DESCRIPTION :
  --   Returns the product x*y of two triple doubles, x and y.

    res : triple_double;
    f0,f1,f2,f3,p,e : double_float;

  begin
    f3 := x.mi*y.lo;
    f3 := f3 + x.lo*y.mi;
    Double_Double_Basics.two_prod(x.hi,y.lo,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_prod(x.mi,y.mi,p,e);
    f3 := f3 + e;
    Double_Double_Basics.two_sum(f2,p,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_prod(x.lo,y.hi,p,e);
    f3 := f3 + e;
    Double_Double_Basics.two_sum(f2,p,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_prod(x.hi,y.mi,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_prod(x.mi,y.hi,p,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_sum(f1,p,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_prod(x.hi,y.hi,f0,e);
    Double_Double_Basics.two_sum(f1,e,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    fast_renorm(f0,f1,f2,f3,res.hi,res.mi,res.lo);
    return res;
  end "*";

  function "*" ( x : triple_double; y : double_float ) return triple_double is

  -- DESCRIPTION :
  --   Returns the product x*y of the triple double x with the double y.

    res : triple_double;
    f0,f1,f2,f3,e : double_float;

  begin
    f3 := 0.0;
    Double_Double_Basics.two_prod(x.lo,y,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_prod(x.mi,y,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    Double_Double_Basics.two_prod(x.hi,y,f0,e);
    Double_Double_Basics.two_sum(f1,e,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    f3 := f3 + e;
    fast_renorm(f0,f1,f2,f3,res.hi,res.mi,res.lo);
    return res;
  end "*";

  function "*" ( x : double_float; y : triple_double ) return triple_double is

  -- DESCRIPTION :
  --   Returns the produce x*y of the double x with the triple double y.

  begin
    return y*x;
  end "*";

  function "/" ( x,y : triple_double ) return triple_double is

  -- DESCRIPTION :
  --   Returns the quotient x/y of the triple doubles x and y.

    res,acc : triple_double;
    q0,q1,q2,q3 : double_float;

  begin
    q0 := x.hi/y.hi;   acc := q0*y; res := x - acc;
    q1 := res.hi/y.hi; acc := q1*y; res := res - acc;
    q2 := res.hi/y.hi; acc := q2*y; res := res - acc;
    q3 := res.hi/y.hi;
    fast_renorm(q0,q1,q2,q3,res.hi,res.mi,res.lo);
    return res;
  end "/";

  procedure Test_Basic_Arithmetic is

  -- DESCRIPTION :
  --   Generates random numbers and compares with quad double arithmetic.
  --   The sin and cos functions are applied to have four nonzero words.

    qdx : constant quad_double
        := QuadDobl_Mathematical_Functions.sin(Random);
    qdy : constant quad_double
        := QuadDobl_Mathematical_Functions.cos(Random);
    qdz : constant quad_double := qdx + qdy;
    tdx : constant triple_double := to_triple_double(qdx);
    tdy : constant triple_double := to_triple_double(qdy);
    tdz : constant triple_double := tdx + tdy;
    qtx : constant quad_double := create(tdx);
    qty : constant quad_double := create(tdy);
    qtz : constant quad_double := create(tdz);
    df1 : constant quad_double := qdz - qtz;
    tdv : constant triple_double := tdz - tdy;
    qtv : constant quad_double := create(tdv);
    df2 : constant quad_double := qdx - qtv;
    qdp : constant quad_double := qdx * qdy;
    tdp : constant triple_double := tdx * tdy;
    qtp : constant quad_double := create(tdp);
    df3 : constant quad_double := qdp - qtp;
    dy : constant double_float := hihi_part(qdy);
    qdxdy : constant quad_double := qdx*dy;
    tdxdy : constant triple_double := tdx*dy;
    qtxdy : constant quad_double := create(tdxdy);
    df4 : constant quad_double := qdxdy - qtxdy;
    qdq : constant quad_double := qdx / qdy;
    tdq : constant triple_double := tdx / tdy;
    qtq : constant quad_double := create(tdq);
    df5 : constant quad_double := qdq - qtq;

  begin
    put_line("The sum of two random quad doubles :");
    put("    x : "); put(qdx); new_line;
    put("    y : "); put(qdy); new_line;
    put("x + y : "); put(qdz); new_line;
    put_line("The same sum with triple doubles :");
    put("    x : "); put(qtx); new_line;
    put("    y : "); put(qty); new_line;
    put("x + y : "); put(qtz); new_line;
    put_line("The difference :"); put(df1); new_line;
    put("(x+y)-y : "); put(qtv); new_line;
    put("      x : "); put(qtx); new_line;
    put_line("The difference :"); put(df2); new_line;
    put("qd x*y :"); put(qdp); new_line;
    put("td x*y :"); put(qtp); new_line;
    put_line("The difference :"); put(df3); new_line;
    put("qd x*dy :"); put(qdxdy); new_line;
    put("td x*dy :"); put(qtxdy); new_line;
    put_line("The difference :"); put(df4); new_line;
    put("qd x/y :"); put(qdq); new_line;
    put("td x/y :"); put(qtq); new_line;
    put_line("The difference :"); put(df5); new_line;
  end Test_Basic_Arithmetic;

  procedure Main is
  begin
    new_line;
    put_line("Testing triple double arithmetic ...");
    Test_Basic_Arithmetic;
  end Main;

begin
  Main;
end ts_tridbl;

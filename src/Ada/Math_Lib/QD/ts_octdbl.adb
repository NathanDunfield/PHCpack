with text_io;                            use text_io;
with Standard_Floating_Numbers;          use Standard_Floating_Numbers;
with Standard_Floating_Numbers_io;       use Standard_Floating_Numbers_io;
with Standard_Random_Numbers;
with Double_Double_Basics;

procedure ts_octdbl is

-- DESCRIPTION :
--   Development of arithmetic with 8-fold doubles "octo doubles"
--   with the help of generated code of the CAMPARY library.

-- DATA STRUCTURE :
--   An octo double could be viewed as a double quad double number,
--   or a quad double double number.  The naming of the parts of an
--   octo double is consistent with replacing the four doubles of a
--   quad double (called hihi, lohi, hilo, and lolo) by double doubles,
--   each with a high and low part.  The high and low part are used to
--   prefix the new names, so the lohi has parts hilohi and lolohi.
--   The first four highest parts all have hi as suffix,
--   the first four lowest parts all have lo as suffix.
--   The eight parts of an octo double are eight doubles in a record.
--   In a corresponding array data type they would be named 
--   x0, x1, x2, x3, x4, x5, x6, x7 in order of significance.

  type octo_double is record
    hihihi : double_float; -- highest word, most significant part
    lohihi : double_float; -- second highest word
    hilohi : double_float; -- third highest word
    lolohi : double_float; -- fourth highest word
    hihilo : double_float; -- fourth lowest word
    lohilo : double_float; -- third lowest word
    hilolo : double_float; -- second lowest word
    lololo : double_float; -- lowest word, least significant part
  end record;

  function create ( x : double_float ) return octo_double is

  -- DESCRIPTION :
  --   The highest word in the octo double on return is x.

    res : octo_double;

  begin
    res.hihihi := x;
    res.lohihi := 0.0;
    res.hilohi := 0.0;
    res.lolohi := 0.0;
    res.hihilo := 0.0;
    res.lohilo := 0.0;
    res.hilolo := 0.0;
    res.lololo := 0.0;
    return res;
  end Create;

  procedure renorm8
              ( f0,f1,f2,f3,f4,f5,f6,f7,f8 : in double_float;
                pr : in out double_float;
                r0,r1,r2,r3,r4,r5,r6,r7 : out double_float ) is

  -- DESCRIPTION :
  --   Definitions common to fast_renorm2L<9,8> and renorm2L_4Add1<8,8>
  --   from code of the specRenorm.h, generated by the CAMPARY library,
  --   in an unrolled form (Valentina Popescu, Mioara Joldes), with
  --   double double basics of QD-2.3.9 (Y. Hida, X.S. Li, and D.H. Bialey).

  -- ON ENTRY :
  --   x0       most significant word;
  --   x1       second most significant word;
  --   x2       third most significant word;
  --   x3       fourth most significant word;
  --   x4       fifth most significant word;
  --   x5       sixth most significant word;
  --   x6       seventh most significant word;
  --   x7       eighth most significant word;
  --   x8       least significant word;
  --   pr       computed by the start of the renormalization.

  -- ON RETURN :
  --   pr       updated value by renormalization;
  --   r0       highest part of an octo double number;
  --   r1       second highest part of an octo double number;
  --   r2       third highest part of an octo double number.
  --   r3       fourth highest part of an octo double number;
  --   r4       fourth lowest part of an octo double number;
  --   r5       third lowest part of an octo double number;
  --   r6       second lowest part of an octo double number;
  --   r7       lowest part of an octo double number.

    ptr : integer;

  begin
    if f1 = 0.0 then
      pr := f0;
      ptr := 0;
      Double_Double_Basics.quick_two_sum(pr,f2,r0,pr);
    else
      r0 := f0;
      pr := f1;
      ptr := 1;
      Double_Double_Basics.quick_two_sum(pr,f2,r1,pr);
    end if;
    if pr = 0.0 then
      if ptr = 0
       then pr := r0;
       else pr := r1;
      end if;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f3,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f3,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f3,r2,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f4,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f4,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f4,r2,pr);
      when 3 => Double_Double_Basics.quick_two_sum(pr,f4,r3,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when 3 => pr := r3;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f5,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f5,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f5,r2,pr);
      when 3 => Double_Double_Basics.quick_two_sum(pr,f5,r3,pr);
      when 4 => Double_Double_Basics.quick_two_sum(pr,f5,r4,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when 3 => pr := r3;
        when 4 => pr := r4;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f6,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f6,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f6,r2,pr);
      when 3 => Double_Double_Basics.quick_two_sum(pr,f6,r3,pr);
      when 4 => Double_Double_Basics.quick_two_sum(pr,f6,r4,pr);
      when 5 => Double_Double_Basics.quick_two_sum(pr,f6,r5,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when 3 => pr := r3;
        when 4 => pr := r4;
        when 5 => pr := r5;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f7,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f7,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f7,r2,pr);
      when 3 => Double_Double_Basics.quick_two_sum(pr,f7,r3,pr);
      when 4 => Double_Double_Basics.quick_two_sum(pr,f7,r4,pr);
      when 5 => Double_Double_Basics.quick_two_sum(pr,f7,r5,pr);
      when 6 => Double_Double_Basics.quick_two_sum(pr,f7,r6,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when 3 => pr := r3;
        when 4 => pr := r4;
        when 5 => pr := r5;
        when 6 => pr := r6;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    case ptr is
      when 0 => Double_Double_Basics.quick_two_sum(pr,f8,r0,pr);
      when 1 => Double_Double_Basics.quick_two_sum(pr,f8,r1,pr);
      when 2 => Double_Double_Basics.quick_two_sum(pr,f8,r2,pr);
      when 3 => Double_Double_Basics.quick_two_sum(pr,f8,r3,pr);
      when 4 => Double_Double_Basics.quick_two_sum(pr,f8,r4,pr);
      when 5 => Double_Double_Basics.quick_two_sum(pr,f8,r5,pr);
      when 6 => Double_Double_Basics.quick_two_sum(pr,f8,r6,pr);
      when 7 => Double_Double_Basics.quick_two_sum(pr,f8,r7,pr);
      when others => null;
    end case;
    if pr = 0.0 then
      case ptr is
        when 0 => pr := r0;
        when 1 => pr := r1;
        when 2 => pr := r2;
        when 3 => pr := r3;
        when 4 => pr := r4;
        when 5 => pr := r5;
        when 6 => pr := r6;
        when 7 => pr := r7;
        when others => null;
      end case;
    else
      ptr := ptr + 1;
    end if;
    if ptr < 8 and pr /= 0.0 then
      case ptr is
        when 0 => r0 := pr;
        when 1 => r1 := pr;
        when 2 => r2 := pr;
        when 3 => r3 := pr;
        when 4 => r4 := pr;
        when 5 => r5 := pr;
        when 6 => r6 := pr;
        when 7 => r7 := pr;
        when others => null;
      end case;
      ptr := ptr + 1;
    end if;
    if ptr < 1 then
      r7 := 0.0; r6 := 0.0; r5 := 0.0; r4 := 0.0; r3 := 0.0; r2 := 0.0;
      r1 := 0.0; r0 := 0.0;
    elsif ptr < 2 then
      r7 := 0.0; r6 := 0.0; r5 := 0.0; r4 := 0.0; r3 := 0.0; r2 := 0.0;
      r1 := 0.0;
    elsif ptr < 3 then
      r7 := 0.0; r6 := 0.0; r5 := 0.0; r4 := 0.0; r3 := 0.0; r2 := 0.0;
    elsif ptr < 4 then
      r7 := 0.0; r6 := 0.0; r5 := 0.0; r4 := 0.0; r3 := 0.0;
    elsif ptr < 5 then
      r7 := 0.0; r6 := 0.0; r5 := 0.0; r4 := 0.0;
    elsif ptr < 6 then
      r7 := 0.0; r6 := 0.0; r5 := 0.0;
    elsif ptr < 7 then
      r7 := 0.0; r6 := 0.0;
    elsif ptr < 8 then
      r7 := 0.0;
    end if;
  end renorm8;

  procedure fast_renorm
              ( x0,x1,x2,x3,x4,x5,x6,x7,x8 : in double_float;
                r0,r1,r2,r3,r4,r5,r6,r7 : out double_float ) is

  -- DESCRIPTION :
  --   The definition is based on the fast_renorm2L<9,8>,
  --   from code of the specRenorm.h, generated by the CAMPARY library,
  --   in an unrolled form (Valentina Popescu, Mioara Joldes), with
  --   double double basics of QD-2.3.9 (Y. Hida, X.S. Li, and D.H. Bialey).

  -- ON ENTRY :
  --   x0       most significant word;
  --   x1       second most significant word;
  --   x2       third most significant word;
  --   x3       fourth most significant word;
  --   x4       fifth most significant word;
  --   x5       sixth most significant word;
  --   x6       seventh most significant word;
  --   x7       eighth most significant word;
  --   x8       least significant word.

  -- ON RETURN :
  --   r0       highest part of an octo double number;
  --   r1       second highest part of an octo double number;
  --   r2       third highest part of an octo double number.
  --   r3       fourth highest part of an octo double number;
  --   r4       fourth lowest part of an octo double number;
  --   r5       third lowest part of an octo double number;
  --   r6       second lowest part of an octo double number;
  --   r7       lowest part of an octo double number.

    f0,f1,f2,f3,f4,f5,f6,f7,f8,pr : double_float;

  begin
    Double_Double_Basics.quick_two_sum(x7,x8,pr,f8);
    Double_Double_Basics.quick_two_sum(x6,pr,pr,f7);
    Double_Double_Basics.quick_two_sum(x5,pr,pr,f6);
    Double_Double_Basics.quick_two_sum(x4,pr,pr,f5);
    Double_Double_Basics.quick_two_sum(x3,pr,pr,f4);
    Double_Double_Basics.quick_two_sum(x2,pr,pr,f3);
    Double_Double_Basics.quick_two_sum(x1,pr,pr,f2);
    Double_Double_Basics.quick_two_sum(x0,pr,f0,f1);
    renorm8(f0,f1,f2,f3,f4,f5,f6,f7,f8,pr,r0,r1,r2,r3,r4,r5,r6,r7);
  end fast_renorm;

  procedure renorm_add1
              ( x0,x1,x2,x3,x4,x5,x6,x7 : in double_float;
                y : in double_float;
                r0,r1,r2,r3,r4,r5,r6,r7 : out double_float ) is

  -- DESCRIPTION :
  --   The definition is based on renorm2L_4Add1<8,8>
  --   from code of the specRenorm.h, generated by the CAMPARY library,
  --   in an unrolled form (Valentina Popescu, Mioara Joldes), with
  --   double double basics of QD-2.3.9 (Y. Hida, X.S. Li, and D.H. Bialey).

  -- ON ENTRY :
  --   x0       most significant word of an octo double x;
  --   x1       second most significant word of an octo double x;
  --   x2       third most significant word of an octo double x;
  --   x3       fourth most significant word of an octo double x;
  --   x4       fourth least significant word of an octo double x;
  --   x5       third least significant word of an octo double x;
  --   x6       second least significant word of an octo double x;
  --   x7       least significant word of an octo double x;
  --   y        double to be added to x.

  -- ON RETURN :
  --   r0       most significant word of x + y;
  --   r1       second most significant word of x + y;
  --   r2       third most significant word of x + y;
  --   r3       fourth most significant word of x + y;
  --   r4       fourth least significant word of x + y;
  --   r5       third least significant word of x + y;
  --   r6       second least significant word of x + y;
  --   r7       least significant word of x + y.

    f0,f1,f2,f3,f4,f5,f6,f7,f8,pr : double_float;

  begin
    Double_Double_Basics.two_sum(x7,y,pr,f8);
    Double_Double_Basics.two_sum(x6,pr,pr,f7);
    Double_Double_Basics.two_sum(x5,pr,pr,f6);
    Double_Double_Basics.two_sum(x4,pr,pr,f5);
    Double_Double_Basics.two_sum(x3,pr,pr,f4);
    Double_Double_Basics.two_sum(x2,pr,pr,f3);
    Double_Double_Basics.two_sum(x1,pr,pr,f2);
    Double_Double_Basics.two_sum(x0,pr,f0,f1);
    renorm8(f0,f1,f2,f3,f4,f5,f6,f7,f8,pr,r0,r1,r2,r3,r4,r5,r6,r7);
  end renorm_add1;

  function "+" ( x,y : octo_double ) return octo_double is

  -- DESCRIPTION :
  --   Returns the sum x+y of two octo doubles x and y.

  -- ALGORITHM : baileyAdd_fast<8,8,8> generated by CAMPARY.

    res : octo_double;
    f0,f1,f2,f3,f4,f5,f6,f7,f8,e : double_float;

  begin
    f8 := 0.0;
    Double_Double_Basics.two_sum(x.lololo,y.lololo,f7,e);
    f8 := f8 + e;
    Double_Double_Basics.two_sum(x.hilolo,y.hilolo,f6,e);
    Double_Double_Basics.two_sum(f7,e,f7,e);
    f8 := f8 + e;
    Double_Double_Basics.two_sum(x.lohilo,y.lohilo,f5,e);
    Double_Double_Basics.two_sum(f6,e,f6,e);
    Double_Double_Basics.two_sum(f7,e,f7,e);
    f8 := f8 + e;
    Double_Double_Basics.two_sum(x.hihilo,y.hihilo,f4,e);
    Double_Double_Basics.two_sum(f5,e,f5,e);
    Double_Double_Basics.two_sum(f6,e,f6,e);
    Double_Double_Basics.two_sum(f7,e,f7,e);
    f8 := f8 + e;
    Double_Double_Basics.two_sum(x.lolohi,y.lolohi,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    Double_Double_Basics.two_sum(f5,e,f5,e);
    Double_Double_Basics.two_sum(f6,e,f6,e);
    Double_Double_Basics.two_sum(f7,e,f7,e);
    f8 := f8 + e;
    Double_Double_Basics.two_sum(x.hilohi,y.hilohi,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    Double_Double_Basics.two_sum(f5,e,f5,e);
    Double_Double_Basics.two_sum(f6,e,f6,e);
    Double_Double_Basics.two_sum(f7,e,f7,e);
    f8 := f8 + e;
    Double_Double_Basics.two_sum(x.lohihi,y.lohihi,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    Double_Double_Basics.two_sum(f5,e,f5,e);
    Double_Double_Basics.two_sum(f6,e,f6,e);
    Double_Double_Basics.two_sum(f7,e,f7,e);
    f8 := f8 + e;
    Double_Double_Basics.two_sum(x.hihihi,y.hihihi,f0,e);
    Double_Double_Basics.two_sum(f1,e,f1,e);
    Double_Double_Basics.two_sum(f2,e,f2,e);
    Double_Double_Basics.two_sum(f3,e,f3,e);
    Double_Double_Basics.two_sum(f4,e,f4,e);
    Double_Double_Basics.two_sum(f5,e,f5,e);
    Double_Double_Basics.two_sum(f6,e,f6,e);
    Double_Double_Basics.two_sum(f7,e,f7,e);
    f8 := f8 + e;
    fast_renorm(f0,f1,f2,f3,f4,f5,f6,f7,f8,
                res.hihihi,res.lohihi,res.hilohi,res.lolohi,
                res.hihilo,res.lohilo,res.hilolo,res.lololo);
    return res;
  end "+";

  function "+" ( x : octo_double; y : double_float ) return octo_double is

  -- DESCRIPTION :
  --   Returns the sum of the octo double x with the double y.

    res : octo_double;

  begin
    renorm_add1(x.hihihi,x.lohihi,x.hilohi,x.lolohi,
                x.hihilo,x.lohilo,x.hilolo,x.lololo,y,
                res.hihihi,res.lohihi,res.hilohi,res.lolohi,
                res.hihilo,res.lohilo,res.hilolo,res.lololo);
    return res;
  end "+";

  function "-" ( x : octo_double ) return octo_double is

  -- DESCRIPTION :
  --   Returns -x, flipping the signs of all parts of x.

    res : octo_double;

  begin
    res.hihihi := -x.hihihi;
    res.lohihi := -x.lohihi;
    res.hilohi := -x.hilohi;
    res.lolohi := -x.lolohi;
    res.hihilo := -x.hihilo;
    res.lohilo := -x.lohilo;
    res.hilolo := -x.hilolo;
    res.lololo := -x.lololo;
    return res;
  end "-";

  function "-" ( x,y : octo_double ) return octo_double is

  -- DESCRIPTION :
  --   Returns x-y, of two octo doubles x and y.

    mny : constant octo_double := -y;
    res : constant octo_double := x + mny;

  begin
    return res;
  end "-";

  function random return octo_double is

  -- DESCRIPTION :
  --   Returns a random octo double number from adding
  --   random double numbers in [-1,+1].

    res : octo_double;
    first : constant double_float := Standard_Random_Numbers.Random; 
    second : double_float := Standard_Random_Numbers.Random; 
    eps : constant double_float := 2.0**(-52);
    multiplier : double_float := eps;

  begin
    res := create(first);
    res := res + eps*second;
    for k in 3..8 loop
      multiplier := eps*multiplier;
      second := Standard_Random_Numbers.Random;
      res := res + multiplier*second;
    end loop;
    return res;
  end random;

  procedure Write ( x : in octo_double ) is

  -- DESCRIPTION :
  --   Writes all parts of x, one part per line.

  begin
    put("  hihihi : "); put(x.hihihi); new_line;
    put("  lohihi : "); put(x.lohihi); new_line;
    put("  hilohi : "); put(x.hilohi); new_line;
    put("  lolohi : "); put(x.lolohi); new_line;
    put("  hihilo : "); put(x.hihilo); new_line;
    put("  lohilo : "); put(x.lohilo); new_line;
    put("  hilolo : "); put(x.hilolo); new_line;
    put("  lololo : "); put(x.lololo); new_line;
  end Write;

  procedure Test_Add_and_Subtract is

  -- DESCRIPTION :
  --   Generates two random numbers, adds and subtracts.

    x : constant octo_double := random;
    y : constant octo_double := random;
    z : constant octo_double := x + y;
    v : constant octo_double := z - y;

  begin
   put_line("All parts of a random octo double x :"); Write(x);
   put_line("All parts of a random octo double y :"); Write(y);
   put_line("All parts of a x + y :"); Write(z);
   put_line("All parts of a (x + y) - y :"); Write(v);
  end Test_Add_and_Subtract;

  procedure Main is

  -- DESCRIPTION :
  --   Launches tests.

  begin
    new_line;
    put_line("Testing octo double arithmetic ...");
    Test_Add_and_Subtract;
  end Main;

begin
  Main;
end ts_octdbl;
